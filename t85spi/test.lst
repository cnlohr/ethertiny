GAS LISTING /tmp/ccLNiDUh.s 			page 1


   1               		.file	"test.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
 114               	.global	delay_ms
 116               	delay_ms:
 117               		.stabd	46,0,0
   1:test.c        **** /*
   2:test.c        **** 
   3:test.c        **** 	WARNING: Connecting an AVR to ethernet without magnetics is VERY DANGEROUS.
   4:test.c        **** 	It may cause high voltages to go through the AVR and destroy it in DANGEROUS
   5:test.c        **** 	that may harm personal safety.  Do only at your own risk.
   6:test.c        **** 
   7:test.c        **** */
   8:test.c        **** 
   9:test.c        **** /*
  10:test.c        ****     Copyright (C) 2014 <>< Charles Lohr
  11:test.c        **** 
  12:test.c        **** 
  13:test.c        ****     Permission is hereby granted, free of charge, to any person obtaining a
  14:test.c        **** 	copy of this software and associated documentation files (the "Software"),
  15:test.c        **** 	to deal in the Software without restriction, including without limitation
  16:test.c        **** 	the rights to use, copy, modify, merge, publish, distribute, sublicense,
  17:test.c        **** 	and/or sell copies of the Software, and to permit persons to whom the
  18:test.c        **** 	Software is furnished to do so, subject to the following conditions:
  19:test.c        **** 
  20:test.c        ****     The above copyright notice and this permission notice shall be included
  21:test.c        **** 	in all copies or substantial portions of the Software.
  22:test.c        **** 
  23:test.c        ****     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  24:test.c        **** 	OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  25:test.c        **** 	MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  26:test.c        **** 	IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
  27:test.c        **** 	CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
  28:test.c        **** 	TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  29:test.c        **** 	SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  30:test.c        **** */
  31:test.c        **** 
  32:test.c        **** 
  33:test.c        **** #include <avr/io.h>
  34:test.c        **** #include <avr/interrupt.h>
  35:test.c        **** #include <avr/sleep.h>
  36:test.c        **** #include <util/delay.h>
  37:test.c        **** 
  38:test.c        **** #include "sendpack.h"
  39:test.c        **** #include "packetmater.h"
  40:test.c        **** 
  41:test.c        **** void delay_ms(uint32_t time) {
 119               	.LM0:
 120               	.LFBB1:
 121 0000 0F93      		push r16
 122 0002 1F93      		push r17
 123               	/* prologue: function */
GAS LISTING /tmp/ccLNiDUh.s 			page 2


 124               	/* frame size = 0 */
 125               	/* stack size = 2 */
 126               	.L__stack_usage = 2
  42:test.c        ****   uint32_t i;
  43:test.c        ****   for (i = 0; i < time; i++) {
 128               	.LM1:
 129 0004 00E0      		ldi r16,0
 130 0006 10E0      		ldi r17,0
 131 0008 9801      		movw r18,r16
 132               	.L2:
 134               	.LM2:
 135 000a 0617      		cp r16,r22
 136 000c 1707      		cpc r17,r23
 137 000e 2807      		cpc r18,r24
 138 0010 3907      		cpc r19,r25
 139 0012 01F0      		breq .L5
 140               	.LBB4:
 141               	.LBB5:
 143               	.Ltext1:
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
GAS LISTING /tmp/ccLNiDUh.s 			page 3


  39:/usr/lib/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/avr/include/util/delay.h **** #endif
  41:/usr/lib/avr/include/util/delay.h **** 
  42:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/avr/include/util/delay.h **** 
  46:/usr/lib/avr/include/util/delay.h **** /** \file */
  47:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/avr/include/util/delay.h ****     \code
  49:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/avr/include/util/delay.h ****     \endcode
  53:/usr/lib/avr/include/util/delay.h **** 
  54:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/avr/include/util/delay.h ****     used.
  58:/usr/lib/avr/include/util/delay.h **** 
  59:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/avr/include/util/delay.h **** 
  68:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/avr/include/util/delay.h **** 
  77:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/avr/include/util/delay.h **** 
  81:/usr/lib/avr/include/util/delay.h **** */
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/avr/include/util/delay.h **** #endif
  87:/usr/lib/avr/include/util/delay.h **** 
  88:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/avr/include/util/delay.h **** #endif
  93:/usr/lib/avr/include/util/delay.h **** 
  94:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
GAS LISTING /tmp/ccLNiDUh.s 			page 4


  96:/usr/lib/avr/include/util/delay.h **** #endif
  97:/usr/lib/avr/include/util/delay.h **** 
  98:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/avr/include/util/delay.h **** #endif
 103:/usr/lib/avr/include/util/delay.h **** 
 104:/usr/lib/avr/include/util/delay.h **** /**
 105:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/avr/include/util/delay.h **** 
 107:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/avr/include/util/delay.h **** 
 109:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/avr/include/util/delay.h **** 
 112:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/avr/include/util/delay.h **** 
 114:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/avr/include/util/delay.h **** 
 120:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/avr/include/util/delay.h **** 
 125:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/avr/include/util/delay.h **** 
 132:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/avr/include/util/delay.h **** 
 140:/usr/lib/avr/include/util/delay.h ****  */
 141:/usr/lib/avr/include/util/delay.h **** void
 142:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/avr/include/util/delay.h **** {
 144:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 146:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 149:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 150:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 151:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:/usr/lib/avr/include/util/delay.h **** 
GAS LISTING /tmp/ccLNiDUh.s 			page 5


 153:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:/usr/lib/avr/include/util/delay.h **** 
 156:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:/usr/lib/avr/include/util/delay.h **** 
 159:/usr/lib/avr/include/util/delay.h **** 	#else
 160:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 161:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:/usr/lib/avr/include/util/delay.h **** 	#endif
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 145               	.LM3:
 146 0014 E7E8      		ldi r30,lo8(4999)
 147 0016 F3E1      		ldi r31,hi8(4999)
 148 0018 3197      		1: sbiw r30,1
 149 001a 01F4      		brne 1b
 150 001c 00C0      		rjmp .
 151 001e 0000      		nop
 152               	.LBE5:
 153               	.LBE4:
 155               	.Ltext2:
 157               	.LM4:
 158 0020 0F5F      		subi r16,-1
 159 0022 1F4F      		sbci r17,-1
 160 0024 2F4F      		sbci r18,-1
 161 0026 3F4F      		sbci r19,-1
 162 0028 00C0      		rjmp .L2
 163               	.L5:
 164               	/* epilogue start */
  44:test.c        ****     _delay_ms(1);
  45:test.c        ****   }
  46:test.c        **** }
 166               	.LM5:
 167 002a 1F91      		pop r17
 168 002c 0F91      		pop r16
 169 002e 0895      		ret
 174               	.Lscope1:
 176               		.stabd	78,0,0
 181               	.global	waitforpacket
 183               	waitforpacket:
 184               		.stabd	46,0,0
  47:test.c        **** 
  48:test.c        **** #define NOOP asm volatile("nop" ::)
  49:test.c        **** 
  50:test.c        **** #define OSC20 0xB6
  51:test.c        **** //#define OSCHIGH 0xda  //~25 MHz???
  52:test.c        **** #define OSCHIGH 0xFF  //~30 MHz?
  53:test.c        **** 
  54:test.c        **** 
  55:test.c        **** static void setup_clock( void )
  56:test.c        **** {
  57:test.c        **** 	/*Examine Page 33*/
  58:test.c        **** 
  59:test.c        **** 	CLKPR = 0x80;	/*Setup CLKPCE to be receptive*/
  60:test.c        **** 	CLKPR = 0x00;	/*No scalar*/
  61:test.c        **** 
GAS LISTING /tmp/ccLNiDUh.s 			page 6


  62:test.c        **** 
  63:test.c        **** 	PLLCSR = _BV(PLLE) | _BV( PCKE );
  64:test.c        **** 	PLLCSR |= _BV(LSM);
  65:test.c        **** 	OSCCAL = OSC20;
  66:test.c        **** 
  67:test.c        **** }
  68:test.c        **** 
  69:test.c        **** //#define SMARTPWR
  70:test.c        **** 
  71:test.c        **** //Inverting the manchester seems to universally make things worse.
  72:test.c        **** //#define INVERT_MANCHESTER
  73:test.c        **** 
  74:test.c        **** #ifndef INVERT_MANCHESTER
  75:test.c        **** //Do not split this across byte-addressing boundaries.
  76:test.c        **** char ManchesterTable[16] __attribute__ ((aligned (16))) = {
  77:test.c        **** 	0b10101010, 0b01101010, 0b10011010, 0b01011010,
  78:test.c        **** 	0b10100110, 0b01100110, 0b10010110, 0b01010110,
  79:test.c        **** 	0b10101001, 0b01101001, 0b10011001, 0b01011001,
  80:test.c        **** 	0b10100101, 0b01100101, 0b10010101, 0b01010101,
  81:test.c        **** };
  82:test.c        **** #else
  83:test.c        **** //Inverted
  84:test.c        **** char ManchesterTable[16] __attribute__ ((aligned (16))) = {
  85:test.c        **** 	0b01010101, 0b10010101, 0b01100101, 0b10100101,
  86:test.c        **** 	0b01011001, 0b10011001, 0b01101001, 0b10101001,
  87:test.c        **** 	0b01010110, 0b10010110, 0b01100110, 0b10100110,
  88:test.c        **** 	0b01011010, 0b10011010, 0b01101010, 0b10101010,
  89:test.c        **** };
  90:test.c        **** #endif
  91:test.c        **** /*
  92:test.c        **** //Debug
  93:test.c        **** char ManchesterTableDEBUG[16] __attribute__ ((aligned (16))) = {
  94:test.c        **** 	0b00000000, 0b11000000, 0b00110000, 0b11110000,
  95:test.c        **** 	0b00001100, 0b11001100, 0b00111100, 0b11111100,
  96:test.c        **** 	0b00000011, 0b11000011, 0b00110011, 0b11110011,
  97:test.c        **** 	0b00001111, 0b11001111, 0b00111111, 0b11111111,
  98:test.c        **** };
  99:test.c        **** */
 100:test.c        **** unsigned char sendbuffer[390];
 101:test.c        **** 
 102:test.c        **** void SendTestASM( const unsigned char * c, uint8_t len );
 103:test.c        **** int MaybeHaveDataASM( unsigned char * c, uint8_t lenX2 ); //returns the number of pairs.
 104:test.c        **** 
 105:test.c        **** /*
 106:test.c        **** void MaybeHaveDataTest( unsigned char * c, uint8_t lenX2 ) //LenX2 = 128->256, i.e. put in half the
 107:test.c        **** {
 108:test.c        **** 	while( lenX2-- )
 109:test.c        **** 	{
 110:test.c        **** 		*(c++) = USIBR;
 111:test.c        **** 		*(c++) = USIBR;
 112:test.c        **** 	}
 113:test.c        **** }*/
 114:test.c        **** 
 115:test.c        **** void waitforpacket( unsigned char * buffer, uint16_t len, int16_t ltime )
 116:test.c        **** {
 186               	.LM6:
 187               	.LFBB2:
GAS LISTING /tmp/ccLNiDUh.s 			page 7


 188 0030 0F93      		push r16
 189 0032 1F93      		push r17
 190 0034 CF93      		push r28
 191 0036 DF93      		push r29
 192               	/* prologue: function */
 193               	/* frame size = 0 */
 194               	/* stack size = 4 */
 195               	.L__stack_usage = 4
 196 0038 8B01      		movw r16,r22
 197 003a EA01      		movw r28,r20
 117:test.c        **** 		OSCCAL = OSCHIGH;
 199               	.LM7:
 200 003c 2FEF      		ldi r18,lo8(-1)
 201 003e 21BF      		out 0x31,r18
 202               	.L7:
 118:test.c        **** 
 119:test.c        **** 	//Make sure we're not walking in on something.
 120:test.c        **** 	while( ltime-- > 0 )
 204               	.LM8:
 205 0040 2197      		sbiw r28,1
 206 0042 9E01      		movw r18,r28
 207 0044 2F5F      		subi r18,-1
 208 0046 3F4F      		sbci r19,-1
 209 0048 1216      		cp __zero_reg__,r18
 210 004a 1306      		cpc __zero_reg__,r19
 211 004c 04F4      		brge .L12
 121:test.c        **** 	{
 122:test.c        **** 		if( USIBR == 0x00 ) break;
 213               	.LM9:
 214 004e 20B3      		in r18,0x10
 215 0050 2223      		tst r18
 216 0052 01F0      		breq .L12
 123:test.c        **** 		if( USIBR == 0xFF ) break;
 218               	.LM10:
 219 0054 20B3      		in r18,0x10
 220 0056 2F3F      		cpi r18,lo8(-1)
 221 0058 01F0      		breq .L12
 124:test.c        **** 		NOOP;
 223               	.LM11:
 224               	/* #APP */
 225               	 ;  124 "test.c" 1
 226 005a 0000      		nop
 227               	 ;  0 "" 2
 228               	/* #NOAPP */
 229 005c 00C0      		rjmp .L7
 230               	.L13:
 125:test.c        **** 	}
 126:test.c        **** 
 127:test.c        **** 
 128:test.c        **** 	while( ltime-- > 0 )
 129:test.c        **** 	{
 130:test.c        **** 		if( USIBR && (USIBR != 0xFF ) )
 232               	.LM12:
 233 005e 20B3      		in r18,0x10
 234 0060 2111      		cpse r18,__zero_reg__
 235 0062 00C0      		rjmp .L28
 236               	.L12:
GAS LISTING /tmp/ccLNiDUh.s 			page 8


 128:test.c        **** 	while( ltime-- > 0 )
 238               	.LM13:
 239 0064 2197      		sbiw r28,1
 240 0066 9E01      		movw r18,r28
 241 0068 2F5F      		subi r18,-1
 242 006a 3F4F      		sbci r19,-1
 243 006c 1216      		cp __zero_reg__,r18
 244 006e 1306      		cpc __zero_reg__,r19
 245 0070 04F0      		brlt .L13
 246 0072 00C0      		rjmp .L11
 247               	.L28:
 249               	.LM14:
 250 0074 20B3      		in r18,0x10
 251 0076 2F3F      		cpi r18,lo8(-1)
 252 0078 01F0      		breq .L12
 253               	.LBB6:
 131:test.c        **** 		{
 132:test.c        **** 			int r = MaybeHaveDataASM( buffer, len );
 255               	.LM15:
 256 007a 602F      		mov r22,r16
 257 007c 00D0      		rcall MaybeHaveDataASM
 133:test.c        **** 			ltime-=(len-r)*4+3; //About how long the function takes to execute.
 259               	.LM16:
 260 007e 2397      		sbiw r28,3
 261 0080 B801      		movw r22,r16
 262 0082 681B      		sub r22,r24
 263 0084 790B      		sbc r23,r25
 264 0086 660F      		lsl r22
 265 0088 771F      		rol r23
 266 008a 660F      		lsl r22
 267 008c 771F      		rol r23
 268 008e C61B      		sub r28,r22
 269 0090 D70B      		sbc r29,r23
 270               	.L11:
 271               	.LBE6:
 134:test.c        **** 			break;
 135:test.c        **** 		}
 136:test.c        **** //		NOOP;
 137:test.c        **** //		NOOP;
 138:test.c        **** //		NOOP;
 139:test.c        **** 	}
 140:test.c        **** 
 141:test.c        **** 	while( ltime-- > 0 )
 273               	.LM17:
 274 0092 1C16      		cp __zero_reg__,r28
 275 0094 1D06      		cpc __zero_reg__,r29
 276 0096 04F4      		brge .L29
 142:test.c        **** 	{
 143:test.c        **** 		NOOP;
 278               	.LM18:
 279               	/* #APP */
 280               	 ;  143 "test.c" 1
 281 0098 0000      		nop
 282               	 ;  0 "" 2
 144:test.c        **** 		NOOP;
 284               	.LM19:
 285               	 ;  144 "test.c" 1
GAS LISTING /tmp/ccLNiDUh.s 			page 9


 286 009a 0000      		nop
 287               	 ;  0 "" 2
 145:test.c        **** 		NOOP;
 289               	.LM20:
 290               	 ;  145 "test.c" 1
 291 009c 0000      		nop
 292               	 ;  0 "" 2
 146:test.c        **** 		NOOP;
 294               	.LM21:
 295               	 ;  146 "test.c" 1
 296 009e 0000      		nop
 297               	 ;  0 "" 2
 147:test.c        **** 		NOOP;
 299               	.LM22:
 300               	 ;  147 "test.c" 1
 301 00a0 0000      		nop
 302               	 ;  0 "" 2
 303               	/* #NOAPP */
 304 00a2 2197      		sbiw r28,1
 305 00a4 00C0      		rjmp .L11
 306               	.L29:
 148:test.c        **** 	}
 149:test.c        **** 
 150:test.c        **** 	OSCCAL = OSC20;
 308               	.LM23:
 309 00a6 86EB      		ldi r24,lo8(-74)
 310 00a8 81BF      		out 0x31,r24
 311               	/* epilogue start */
 151:test.c        **** }
 313               	.LM24:
 314 00aa DF91      		pop r29
 315 00ac CF91      		pop r28
 316 00ae 1F91      		pop r17
 317 00b0 0F91      		pop r16
 318 00b2 0895      		ret
 320               	.Lscope2:
 322               		.stabd	78,0,0
 323               		.section	.text.startup,"ax",@progbits
 325               	.global	main
 327               	main:
 328               		.stabd	46,0,0
 152:test.c        **** 
 153:test.c        **** 
 154:test.c        **** int main( )
 155:test.c        **** {
 330               	.LM25:
 331               	.LFBB3:
 332               	/* prologue: function */
 333               	/* frame size = 0 */
 334               	/* stack size = 0 */
 335               	.L__stack_usage = 0
 156:test.c        **** 	int i;
 157:test.c        **** 	cli();
 337               	.LM26:
 338               	/* #APP */
 339               	 ;  157 "test.c" 1
 340 0000 F894      		cli
GAS LISTING /tmp/ccLNiDUh.s 			page 10


 341               	 ;  0 "" 2
 342               	/* #NOAPP */
 343               	.LBB11:
 344               	.LBB12:
  59:test.c        **** 	CLKPR = 0x80;	/*Setup CLKPCE to be receptive*/
 346               	.LM27:
 347 0002 80E8      		ldi r24,lo8(-128)
 348 0004 86BD      		out 0x26,r24
  60:test.c        **** 	CLKPR = 0x00;	/*No scalar*/
 350               	.LM28:
 351 0006 16BC      		out 0x26,__zero_reg__
  63:test.c        **** 	PLLCSR = _BV(PLLE) | _BV( PCKE );
 353               	.LM29:
 354 0008 86E0      		ldi r24,lo8(6)
 355 000a 87BD      		out 0x27,r24
  64:test.c        **** 	PLLCSR |= _BV(LSM);
 357               	.LM30:
 358 000c 87B5      		in r24,0x27
 359 000e 8068      		ori r24,lo8(-128)
 360 0010 87BD      		out 0x27,r24
  65:test.c        **** 	OSCCAL = OSC20;
 362               	.LM31:
 363 0012 86EB      		ldi r24,lo8(-74)
 364 0014 81BF      		out 0x31,r24
 365               	.LBE12:
 366               	.LBE11:
 158:test.c        **** 
 159:test.c        **** 	setup_clock();
 160:test.c        **** 
 161:test.c        **** 	DDRB = _BV(1);
 368               	.LM32:
 369 0016 82E0      		ldi r24,lo8(2)
 370 0018 87BB      		out 0x17,r24
 162:test.c        **** 
 163:test.c        **** 	//1st let's see how fast we can clock the pin.
 164:test.c        **** 
 165:test.c        **** 
 166:test.c        **** 	TCCR0A = _BV(WGM01);
 372               	.LM33:
 373 001a 8ABD      		out 0x2a,r24
 167:test.c        **** 	TCCR0B = _BV(CS00);
 375               	.LM34:
 376 001c 81E0      		ldi r24,lo8(1)
 377 001e 83BF      		out 0x33,r24
 168:test.c        **** 	OCR0A = 0;
 379               	.LM35:
 380 0020 19BC      		out 0x29,__zero_reg__
 169:test.c        **** 
 170:test.c        **** 	USICR = _BV(USIWM0) | _BV(USICS0) | _BV(USITC);
 382               	.LM36:
 383 0022 85E1      		ldi r24,lo8(21)
 384 0024 8DB9      		out 0xd,r24
 385 0026 80E0      		ldi r24,lo8(PacketA)
 386 0028 90E0      		ldi r25,hi8(PacketA)
 387 002a A0E0      		ldi r26,lo8(sendbuffer)
 388 002c B0E0      		ldi r27,hi8(sendbuffer)
 389               	.L32:
GAS LISTING /tmp/ccLNiDUh.s 			page 11


 390               	.LBB13:
 171:test.c        **** 
 172:test.c        **** 	for( i = 0; i < PacketABytes; i++ )
 173:test.c        **** 	{
 174:test.c        **** 		sendbuffer[i] = pgm_read_word( &PacketA[i] );
 392               	.LM37:
 393 002e FC01      		movw r30,r24
 394               	/* #APP */
 395               	 ;  174 "test.c" 1
 396 0030 2591      		lpm r18, Z+
 397 0032 3491      		lpm r19, Z
 398               		
 399               	 ;  0 "" 2
 400               	/* #NOAPP */
 401               	.LBE13:
 402 0034 2D93      		st X+,r18
 403 0036 0196      		adiw r24,1
 172:test.c        **** 	for( i = 0; i < PacketABytes; i++ )
 405               	.LM38:
 406 0038 20E0      		ldi r18,hi8(PacketA+76)
 407 003a 8030      		cpi r24,lo8(PacketA+76)
 408 003c 9207      		cpc r25,r18
 409 003e 01F4      		brne .L32
 175:test.c        **** 	}
 176:test.c        **** 
 177:test.c        **** 	i = 0;
 178:test.c        **** 
 179:test.c        **** 	int frame = 0;
 180:test.c        **** 
 181:test.c        **** 	struct EthernetPacket * sbe = (struct EthernetPacket*)sendbuffer;
 182:test.c        **** 
 183:test.c        **** //	PORTB |= _BV(0);  //Enable pullups.
 184:test.c        **** 	PORTB &= ~_BV(0); 
 411               	.LM39:
 412 0040 C098      		cbi 0x18,0
 185:test.c        **** 	DDRB &= ~_BV(0);
 414               	.LM40:
 415 0042 B898      		cbi 0x17,0
 186:test.c        **** 	PORTB &= ~_BV(1);
 417               	.LM41:
 418 0044 C198      		cbi 0x18,1
 187:test.c        **** 	USICR &= ~_BV(USIWM0);  //Disable USICR
 420               	.LM42:
 421 0046 6C98      		cbi 0xd,4
 422               	.LBB14:
 188:test.c        **** 
 189:test.c        **** 	while(1)
 190:test.c        **** 	{
 191:test.c        **** 	//	SendTestASM( sendbuffer, PacketABytes/4 + 3 ); //MUST BE DIVISIBLE BY 2 # of bytes.
 192:test.c        **** 	//	continue;
 193:test.c        **** 
 194:test.c        **** #define LIMITSIZE  sizeof( sendbuffer )/2-30
 195:test.c        **** //#define LIMITSIZE 10
 196:test.c        **** 
 197:test.c        **** 		waitforpacket(sbe->payload, LIMITSIZE, 20000); //wait for 2048 cycles (30MHz/8 = 3.75MHz / 30000 
 198:test.c        **** //		_delay_ms(8);
 199:test.c        **** #ifdef SMARTPWR
GAS LISTING /tmp/ccLNiDUh.s 			page 12


 200:test.c        **** 		DDRB |= _BV(1);
 201:test.c        **** #endif
 202:test.c        **** 		PORTB|=_BV(1);
 203:test.c        **** 		NOOP;
 204:test.c        **** 		PORTB &=~_BV(1);
 205:test.c        **** #ifdef SMARTPWR
 206:test.c        **** 		DDRB &= ~_BV(1);
 207:test.c        **** #endif
 208:test.c        **** 		waitforpacket(sbe->payload, LIMITSIZE, 20000); //wait for 2048  (30MHz/8 = 3.75MHz / 30000 = 8ms)
 209:test.c        **** // 		_delay_ms(8);
 210:test.c        **** 
 211:test.c        **** 		i++;
 212:test.c        **** 
 213:test.c        **** 		if( i == 20 )
 214:test.c        **** 		{
 215:test.c        **** #ifdef SMARTPWR
 216:test.c        **** 			DDRB |= _BV(1);
 217:test.c        **** #endif
 218:test.c        **** 
 219:test.c        **** 			//UDP Data starts at byte #50
 220:test.c        **** 			struct EthernetPacket * sbe = (struct EthernetPacket*)sendbuffer;
 221:test.c        **** //			sbe->payload[0] = 0xBB;
 222:test.c        **** //			sbe->payload[1] = frame++;
 223:test.c        **** 			sbe->addyfrom = 0x450a000a;
 424               	.LM43:
 425 0048 2AE0      		ldi r18,lo8(10)
 426 004a C22E      		mov r12,r18
 427 004c D12C      		mov r13,__zero_reg__
 428 004e EC2C      		mov r14,r12
 429 0050 25E4      		ldi r18,lo8(69)
 430 0052 F22E      		mov r15,r18
 431               	.L36:
 432               	.LBE14:
 155:test.c        **** {
 434               	.LM44:
 435 0054 C4E1      		ldi r28,lo8(20)
 436 0056 D0E0      		ldi r29,0
 437               	.L34:
 197:test.c        **** 		waitforpacket(sbe->payload, LIMITSIZE, 20000); //wait for 2048 cycles (30MHz/8 = 3.75MHz / 30000 
 439               	.LM45:
 440 0058 40E2      		ldi r20,lo8(32)
 441 005a 5EE4      		ldi r21,lo8(78)
 442 005c 65EA      		ldi r22,lo8(-91)
 443 005e 70E0      		ldi r23,0
 444 0060 80E0      		ldi r24,lo8(sendbuffer+50)
 445 0062 90E0      		ldi r25,hi8(sendbuffer+50)
 446 0064 00D0      		rcall waitforpacket
 202:test.c        **** 		PORTB|=_BV(1);
 448               	.LM46:
 449 0066 C19A      		sbi 0x18,1
 203:test.c        **** 		NOOP;
 451               	.LM47:
 452               	/* #APP */
 453               	 ;  203 "test.c" 1
 454 0068 0000      		nop
 455               	 ;  0 "" 2
 204:test.c        **** 		PORTB &=~_BV(1);
GAS LISTING /tmp/ccLNiDUh.s 			page 13


 457               	.LM48:
 458               	/* #NOAPP */
 459 006a C198      		cbi 0x18,1
 208:test.c        **** 		waitforpacket(sbe->payload, LIMITSIZE, 20000); //wait for 2048  (30MHz/8 = 3.75MHz / 30000 = 8ms)
 461               	.LM49:
 462 006c 40E2      		ldi r20,lo8(32)
 463 006e 5EE4      		ldi r21,lo8(78)
 464 0070 65EA      		ldi r22,lo8(-91)
 465 0072 70E0      		ldi r23,0
 466 0074 80E0      		ldi r24,lo8(sendbuffer+50)
 467 0076 90E0      		ldi r25,hi8(sendbuffer+50)
 468 0078 00D0      		rcall waitforpacket
 469 007a 2197      		sbiw r28,1
 213:test.c        **** 		if( i == 20 )
 471               	.LM50:
 472 007c 2097      		sbiw r28,0
 473 007e 01F4      		brne .L34
 474               	.LBB15:
 476               	.LM51:
 477 0080 C092 0000 		sts sendbuffer+34,r12
 478 0084 D092 0000 		sts sendbuffer+34+1,r13
 479 0088 E092 0000 		sts sendbuffer+34+2,r14
 480 008c F092 0000 		sts sendbuffer+34+3,r15
 224:test.c        **** 			int rr = Ethernetize( sendbuffer, PacketABytes, 320);
 482               	.LM52:
 483 0090 40E4      		ldi r20,lo8(64)
 484 0092 51E0      		ldi r21,lo8(1)
 485 0094 6CE4      		ldi r22,lo8(76)
 486 0096 70E0      		ldi r23,0
 487 0098 80E0      		ldi r24,lo8(sendbuffer)
 488 009a 90E0      		ldi r25,hi8(sendbuffer)
 489 009c 00D0      		rcall Ethernetize
 225:test.c        **** 
 226:test.c        **** 			SendTestASM( sendbuffer, rr/4 + 3 ); //MUST BE DIVISIBLE BY 2 # of bytes.
 491               	.LM53:
 492 009e 97FD      		sbrc r25,7
 493 00a0 0396      		adiw r24,3
 494               	.L35:
 495 00a2 BC01      		movw r22,r24
 496 00a4 7595      		asr r23
 497 00a6 6795      		ror r22
 498 00a8 7595      		asr r23
 499 00aa 6795      		ror r22
 500 00ac 6D5F      		subi r22,lo8(-(3))
 501 00ae 80E0      		ldi r24,lo8(sendbuffer)
 502 00b0 90E0      		ldi r25,hi8(sendbuffer)
 503 00b2 00D0      		rcall SendTestASM
 504 00b4 00C0      		rjmp .L36
 505               	.LBE15:
 507               	.Lscope3:
 509               		.stabd	78,0,0
 510               		.comm	sendbuffer,390,1
 511               	.global	ManchesterTable
 512               		.data
 513               		.p2align	4
 516               	ManchesterTable:
 517 0000 AA        		.byte	-86
GAS LISTING /tmp/ccLNiDUh.s 			page 14


 518 0001 6A        		.byte	106
 519 0002 9A        		.byte	-102
 520 0003 5A        		.byte	90
 521 0004 A6        		.byte	-90
 522 0005 66        		.byte	102
 523 0006 96        		.byte	-106
 524 0007 56        		.byte	86
 525 0008 A9        		.byte	-87
 526 0009 69        		.byte	105
 527 000a 99        		.byte	-103
 528 000b 59        		.byte	89
 529 000c A5        		.byte	-91
 530 000d 65        		.byte	101
 531 000e 95        		.byte	-107
 532 000f 55        		.byte	85
 535               		.text
 537               	.Letext0:
 538               		.ident	"GCC: (GNU) 4.8.2"
 539               	.global __do_copy_data
 540               	.global __do_clear_bss
GAS LISTING /tmp/ccLNiDUh.s 			page 15


DEFINED SYMBOLS
                            *ABS*:0000000000000000 test.c
     /tmp/ccLNiDUh.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccLNiDUh.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccLNiDUh.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccLNiDUh.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccLNiDUh.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccLNiDUh.s:116    .text:0000000000000000 delay_ms
     /tmp/ccLNiDUh.s:183    .text:0000000000000030 waitforpacket
     /tmp/ccLNiDUh.s:327    .text.startup:0000000000000000 main
                            *COM*:0000000000000186 sendbuffer
     /tmp/ccLNiDUh.s:516    .data:0000000000000000 ManchesterTable

UNDEFINED SYMBOLS
MaybeHaveDataASM
PacketA
Ethernetize
SendTestASM
__do_copy_data
__do_clear_bss
GAS LISTING /tmp/ccLNiDUh.s 			page 1


   1               	# 1 "asmtest.S"
   1               	/*
   1               	...
   0               	
   2               	    Copyright (C) 2014 <>< Charles Lohr
   3               	
   4               	
   5               	    Permission is hereby granted, free of charge, to any person obtaining a
   6               		copy of this software and associated documentation files (the "Software"),
   7               		to deal in the Software without restriction, including without limitation
   8               		the rights to use, copy, modify, merge, publish, distribute, sublicense,
   9               		and/or sell copies of the Software, and to permit persons to whom the
  10               		Software is furnished to do so, subject to the following conditions:
  11               	
  12               	    The above copyright notice and this permission notice shall be included
  13               		in all copies or substantial portions of the Software.
  14               	
  15               	    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  16               		OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  17               		MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  18               		IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
  19               		CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
  20               		TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  21               		SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  22               	*/
  23               	
  24               	
  25               	
  26               	#define _SFR_ASM_COMPAT 1
  27               	#define __SFR_OFFSET 0
  28               	
  29               	#include <avr/io.h>
   1               	/* Copyright (c) 2002,2003,2005,2006,2007 Marek Michalkiewicz, Joerg Wunsch
   2               	   Copyright (c) 2007 Eric B. Weddington
   3               	   All rights reserved.
   4               	
   5               	   Redistribution and use in source and binary forms, with or without
   6               	   modification, are permitted provided that the following conditions are met:
   7               	
   8               	   * Redistributions of source code must retain the above copyright
   9               	     notice, this list of conditions and the following disclaimer.
  10               	
  11               	   * Redistributions in binary form must reproduce the above copyright
  12               	     notice, this list of conditions and the following disclaimer in
  13               	     the documentation and/or other materials provided with the
  14               	     distribution.
  15               	
  16               	   * Neither the name of the copyright holders nor the names of
  17               	     contributors may be used to endorse or promote products derived
  18               	     from this software without specific prior written permission.
  19               	
  20               	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21               	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22               	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23               	  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24               	  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25               	  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
GAS LISTING /tmp/ccLNiDUh.s 			page 2


  26               	  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27               	  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28               	  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29               	  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30               	  POSSIBILITY OF SUCH DAMAGE. */
  31               	
  32               	/* $Id: io.h 2211 2011-02-14 14:04:25Z aboyapati $ */
  33               	
  34               	/** \file */
  35               	/** \defgroup avr_io <avr/io.h>: AVR device-specific IO definitions
  36               	    \code #include <avr/io.h> \endcode
  37               	
  38               	    This header file includes the apropriate IO definitions for the
  39               	    device that has been specified by the <tt>-mmcu=</tt> compiler
  40               	    command-line switch.  This is done by diverting to the appropriate
  41               	    file <tt>&lt;avr/io</tt><em>XXXX</em><tt>.h&gt;</tt> which should
  42               	    never be included directly.  Some register names common to all
  43               	    AVR devices are defined directly within <tt>&lt;avr/common.h&gt;</tt>,
  44               	    which is included in <tt>&lt;avr/io.h&gt;</tt>,
  45               	    but most of the details come from the respective include file.
  46               	
  47               	    Note that this file always includes the following files:
  48               	    \code 
  49               	    #include <avr/sfr_defs.h>
  50               	    #include <avr/portpins.h>
  51               	    #include <avr/common.h>
  52               	    #include <avr/version.h>
  53               	    \endcode
  54               	    See \ref avr_sfr for more details about that header file.
  55               	
  56               	    Included are definitions of the IO register set and their
  57               	    respective bit values as specified in the Atmel documentation.
  58               	    Note that inconsistencies in naming conventions,
  59               	    so even identical functions sometimes get different names on
  60               	    different devices.
  61               	
  62               	    Also included are the specific names useable for interrupt
  63               	    function definitions as documented
  64               	    \ref avr_signames "here".
  65               	
  66               	    Finally, the following macros are defined:
  67               	
  68               	    - \b RAMEND
  69               	    <br>
  70               	    The last on-chip RAM address.
  71               	    <br>
  72               	    - \b XRAMEND
  73               	    <br>
  74               	    The last possible RAM location that is addressable. This is equal to 
  75               	    RAMEND for devices that do not allow for external RAM. For devices 
  76               	    that allow external RAM, this will be larger than RAMEND.
  77               	    <br>
  78               	    - \b E2END
  79               	    <br>
  80               	    The last EEPROM address.
  81               	    <br>
  82               	    - \b FLASHEND
GAS LISTING /tmp/ccLNiDUh.s 			page 3


  83               	    <br>
  84               	    The last byte address in the Flash program space.
  85               	    <br>
  86               	    - \b SPM_PAGESIZE
  87               	    <br>
  88               	    For devices with bootloader support, the flash pagesize
  89               	    (in bytes) to be used for the \c SPM instruction. 
  90               	    - \b E2PAGESIZE
  91               	    <br>
  92               	    The size of the EEPROM page.
  93               	    
  94               	*/
  95               	
  96               	#ifndef _AVR_IO_H_
  97               	#define _AVR_IO_H_
  98               	
  99               	#include <avr/sfr_defs.h>
   1               	/* Copyright (c) 2002, Marek Michalkiewicz <marekm@amelek.gda.pl>
 100               	
 101               	#if defined (__AVR_AT94K__)
 102               	#  include <avr/ioat94k.h>
 103               	#elif defined (__AVR_AT43USB320__)
 104               	#  include <avr/io43u32x.h>
 105               	#elif defined (__AVR_AT43USB355__)
 106               	#  include <avr/io43u35x.h>
 107               	#elif defined (__AVR_AT76C711__)
 108               	#  include <avr/io76c711.h>
 109               	#elif defined (__AVR_AT86RF401__)
 110               	#  include <avr/io86r401.h>
 111               	#elif defined (__AVR_AT90PWM1__)
 112               	#  include <avr/io90pwm1.h>
 113               	#elif defined (__AVR_AT90PWM2__)
 114               	#  include <avr/io90pwmx.h>
 115               	#elif defined (__AVR_AT90PWM2B__)
 116               	#  include <avr/io90pwm2b.h>
 117               	#elif defined (__AVR_AT90PWM3__)
 118               	#  include <avr/io90pwmx.h>
 119               	#elif defined (__AVR_AT90PWM3B__)
 120               	#  include <avr/io90pwm3b.h>
 121               	#elif defined (__AVR_AT90PWM216__)
 122               	#  include <avr/io90pwm216.h>
 123               	#elif defined (__AVR_AT90PWM316__)
 124               	#  include <avr/io90pwm316.h>
 125               	#elif defined (__AVR_AT90PWM81__)
 126               	#  include <avr/io90pwm81.h>
 127               	#elif defined (__AVR_ATmega8U2__)
 128               	#  include <avr/iom8u2.h>
 129               	#elif defined (__AVR_ATmega16M1__)
 130               	#  include <avr/iom16m1.h>
 131               	#elif defined (__AVR_ATmega16U2__)
 132               	#  include <avr/iom16u2.h>
 133               	#elif defined (__AVR_ATmega16U4__)
 134               	#  include <avr/iom16u4.h>
 135               	#elif defined (__AVR_ATmega32C1__)
 136               	#  include <avr/iom32c1.h>
 137               	#elif defined (__AVR_ATmega32M1__)
 138               	#  include <avr/iom32m1.h>
GAS LISTING /tmp/ccLNiDUh.s 			page 4


 139               	#elif defined (__AVR_ATmega32U2__)
 140               	#  include <avr/iom32u2.h>
 141               	#elif defined (__AVR_ATmega32U4__)
 142               	#  include <avr/iom32u4.h>
 143               	#elif defined (__AVR_ATmega32U6__)
 144               	#  include <avr/iom32u6.h>
 145               	#elif defined (__AVR_ATmega64C1__)
 146               	#  include <avr/iom64c1.h>
 147               	#elif defined (__AVR_ATmega64M1__)
 148               	#  include <avr/iom64m1.h>
 149               	#elif defined (__AVR_ATmega128__)
 150               	#  include <avr/iom128.h>
 151               	#elif defined (__AVR_ATmega1280__)
 152               	#  include <avr/iom1280.h>
 153               	#elif defined (__AVR_ATmega1281__)
 154               	#  include <avr/iom1281.h>
 155               	#elif defined (__AVR_ATmega1284P__)
 156               	#  include <avr/iom1284p.h>
 157               	#elif defined (__AVR_ATmega128RFA1__)
 158               	#  include <avr/iom128rfa1.h>
 159               	#elif defined (__AVR_ATmega2560__)
 160               	#  include <avr/iom2560.h>
 161               	#elif defined (__AVR_ATmega2561__)
 162               	#  include <avr/iom2561.h>
 163               	#elif defined (__AVR_AT90CAN32__)
 164               	#  include <avr/iocan32.h>
 165               	#elif defined (__AVR_AT90CAN64__)
 166               	#  include <avr/iocan64.h>
 167               	#elif defined (__AVR_AT90CAN128__)
 168               	#  include <avr/iocan128.h>
 169               	#elif defined (__AVR_AT90USB82__)
 170               	#  include <avr/iousb82.h>
 171               	#elif defined (__AVR_AT90USB162__)
 172               	#  include <avr/iousb162.h>
 173               	#elif defined (__AVR_AT90USB646__)
 174               	#  include <avr/iousb646.h>
 175               	#elif defined (__AVR_AT90USB647__)
 176               	#  include <avr/iousb647.h>
 177               	#elif defined (__AVR_AT90USB1286__)
 178               	#  include <avr/iousb1286.h>
 179               	#elif defined (__AVR_AT90USB1287__)
 180               	#  include <avr/iousb1287.h>
 181               	#elif defined (__AVR_ATmega64__)
 182               	#  include <avr/iom64.h>
 183               	#elif defined (__AVR_ATmega640__)
 184               	#  include <avr/iom640.h>
 185               	#elif defined (__AVR_ATmega644__) || defined (__AVR_ATmega644A__)
 186               	#  include <avr/iom644.h>
 187               	#elif defined (__AVR_ATmega644P__)
 188               	#  include <avr/iom644p.h>
 189               	#elif defined (__AVR_ATmega644PA__)
 190               	#  include <avr/iom644pa.h>
 191               	#elif defined (__AVR_ATmega645__) || defined (__AVR_ATmega645A__) || defined (__AVR_ATmega645P__)
 192               	#  include <avr/iom645.h>
 193               	#elif defined (__AVR_ATmega6450__) || defined (__AVR_ATmega6450A__) || defined (__AVR_ATmega6450P__
 194               	#  include <avr/iom6450.h>
 195               	#elif defined (__AVR_ATmega649__) || defined (__AVR_ATmega649A__)
GAS LISTING /tmp/ccLNiDUh.s 			page 5


 196               	#  include <avr/iom649.h>
 197               	#elif defined (__AVR_ATmega6490__) || defined (__AVR_ATmega6490A__) || defined (__AVR_ATmega6490P__
 198               	#  include <avr/iom6490.h>
 199               	#elif defined (__AVR_ATmega649P__)
 200               	#  include <avr/iom649p.h>
 201               	#elif defined (__AVR_ATmega64HVE__)
 202               	#  include <avr/iom64hve.h>
 203               	#elif defined (__AVR_ATmega103__)
 204               	#  include <avr/iom103.h>
 205               	#elif defined (__AVR_ATmega32__)
 206               	#  include <avr/iom32.h>
 207               	#elif defined (__AVR_ATmega323__)
 208               	#  include <avr/iom323.h>
 209               	#elif defined (__AVR_ATmega324P__) || defined (__AVR_ATmega324A__)
 210               	#  include <avr/iom324.h>
 211               	#elif defined (__AVR_ATmega324PA__)
 212               	#  include <avr/iom324pa.h>
 213               	#elif defined (__AVR_ATmega325__) || defined (__AVR_ATmega325A__)
 214               	#  include <avr/iom325.h>
 215               	#elif defined (__AVR_ATmega325P__)
 216               	#  include <avr/iom325.h>
 217               	#elif defined (__AVR_ATmega3250__) || defined (__AVR_ATmega3250A__)
 218               	#  include <avr/iom3250.h>
 219               	#elif defined (__AVR_ATmega3250P__)
 220               	#  include <avr/iom3250.h>
 221               	#elif defined (__AVR_ATmega328P__) || defined (__AVR_ATmega328__)
 222               	#  include <avr/iom328p.h>
 223               	#elif defined (__AVR_ATmega329__) || defined (__AVR_ATmega329A__)
 224               	#  include <avr/iom329.h>
 225               	#elif defined (__AVR_ATmega329P__) || defined (__AVR_ATmega329PA__)
 226               	#  include <avr/iom329.h>
 227               	#elif defined (__AVR_ATmega3290__) || defined (__AVR_ATmega3290A__)
 228               	#  include <avr/iom3290.h>
 229               	#elif defined (__AVR_ATmega3290P__)
 230               	#  include <avr/iom3290.h>
 231               	#elif defined (__AVR_ATmega32HVB__)
 232               	#  include <avr/iom32hvb.h>
 233               	#elif defined (__AVR_ATmega32HVBREVB__)
 234               	#  include <avr/iom32hvbrevb.h>
 235               	#elif defined (__AVR_ATmega406__)
 236               	#  include <avr/iom406.h>
 237               	#elif defined (__AVR_ATmega16__)
 238               	#  include <avr/iom16.h>
 239               	#elif defined (__AVR_ATmega16A__)
 240               	#  include <avr/iom16a.h>
 241               	#elif defined (__AVR_ATmega161__)
 242               	#  include <avr/iom161.h>
 243               	#elif defined (__AVR_ATmega162__)
 244               	#  include <avr/iom162.h>
 245               	#elif defined (__AVR_ATmega163__)
 246               	#  include <avr/iom163.h>
 247               	#elif defined (__AVR_ATmega164P__) || defined (__AVR_ATmega164A__)
 248               	#  include <avr/iom164.h>
 249               	#elif defined (__AVR_ATmega165__) || defined (__AVR_ATmega165A__)
 250               	#  include <avr/iom165.h>
 251               	#elif defined (__AVR_ATmega165P__)
 252               	#  include <avr/iom165p.h>
GAS LISTING /tmp/ccLNiDUh.s 			page 6


 253               	#elif defined (__AVR_ATmega168__) || defined (__AVR_ATmega168A__)
 254               	#  include <avr/iom168.h>
 255               	#elif defined (__AVR_ATmega168P__)
 256               	#  include <avr/iom168p.h>
 257               	#elif defined (__AVR_ATmega169__) || defined (__AVR_ATmega169A__)
 258               	#  include <avr/iom169.h>
 259               	#elif defined (__AVR_ATmega169P__)
 260               	#  include <avr/iom169p.h>
 261               	#elif defined (__AVR_ATmega169PA__)
 262               	#  include <avr/iom169pa.h>
 263               	#elif defined (__AVR_ATmega8HVA__)
 264               	#  include <avr/iom8hva.h>
 265               	#elif defined (__AVR_ATmega16HVA__)
 266               	#  include <avr/iom16hva.h>
 267               	#elif defined (__AVR_ATmega16HVA2__)
 268               	#  include <avr/iom16hva2.h>
 269               	#elif defined (__AVR_ATmega16HVB__)
 270               	#  include <avr/iom16hvb.h>
 271               	#elif defined (__AVR_ATmega16HVBREVB__)
 272               	#  include <avr/iom16hvbrevb.h>
 273               	#elif defined (__AVR_ATmega8__)
 274               	#  include <avr/iom8.h>
 275               	#elif defined (__AVR_ATmega48__) || defined (__AVR_ATmega48A__)
 276               	#  include <avr/iom48.h>
 277               	#elif defined (__AVR_ATmega48P__)
 278               	#  include <avr/iom48p.h>
 279               	#elif defined (__AVR_ATmega88__) || defined (__AVR_ATmega88A__)
 280               	#  include <avr/iom88.h>
 281               	#elif defined (__AVR_ATmega88P__)
 282               	#  include <avr/iom88p.h>
 283               	#elif defined (__AVR_ATmega88PA__)
 284               	#  include <avr/iom88pa.h>
 285               	#elif defined (__AVR_ATmega8515__)
 286               	#  include <avr/iom8515.h>
 287               	#elif defined (__AVR_ATmega8535__)
 288               	#  include <avr/iom8535.h>
 289               	#elif defined (__AVR_AT90S8535__)
 290               	#  include <avr/io8535.h>
 291               	#elif defined (__AVR_AT90C8534__)
 292               	#  include <avr/io8534.h>
 293               	#elif defined (__AVR_AT90S8515__)
 294               	#  include <avr/io8515.h>
 295               	#elif defined (__AVR_AT90S4434__)
 296               	#  include <avr/io4434.h>
 297               	#elif defined (__AVR_AT90S4433__)
 298               	#  include <avr/io4433.h>
 299               	#elif defined (__AVR_AT90S4414__)
 300               	#  include <avr/io4414.h>
 301               	#elif defined (__AVR_ATtiny22__)
 302               	#  include <avr/iotn22.h>
 303               	#elif defined (__AVR_ATtiny26__)
 304               	#  include <avr/iotn26.h>
 305               	#elif defined (__AVR_AT90S2343__)
 306               	#  include <avr/io2343.h>
 307               	#elif defined (__AVR_AT90S2333__)
 308               	#  include <avr/io2333.h>
 309               	#elif defined (__AVR_AT90S2323__)
GAS LISTING /tmp/ccLNiDUh.s 			page 7


 310               	#  include <avr/io2323.h>
 311               	#elif defined (__AVR_AT90S2313__)
 312               	#  include <avr/io2313.h>
 313               	#elif defined (__AVR_ATtiny4__)
 314               	#  include <avr/iotn4.h>
 315               	#elif defined (__AVR_ATtiny5__)
 316               	#  include <avr/iotn5.h>
 317               	#elif defined (__AVR_ATtiny9__)
 318               	#  include <avr/iotn9.h>
 319               	#elif defined (__AVR_ATtiny10__)
 320               	#  include <avr/iotn10.h>
 321               	#elif defined (__AVR_ATtiny20__)
 322               	#  include <avr/iotn20.h>
 323               	#elif defined (__AVR_ATtiny40__)
 324               	#  include <avr/iotn40.h>
 325               	#elif defined (__AVR_ATtiny2313__)
 326               	#  include <avr/iotn2313.h>
 327               	#elif defined (__AVR_ATtiny2313A__)
 328               	#  include <avr/iotn2313a.h>
 329               	#elif defined (__AVR_ATtiny13__)
 330               	#  include <avr/iotn13.h>
 331               	#elif defined (__AVR_ATtiny13A__)
 332               	#  include <avr/iotn13a.h>
 333               	#elif defined (__AVR_ATtiny25__)
 334               	#  include <avr/iotn25.h>
 335               	#elif defined (__AVR_ATtiny4313__)
 336               	#  include <avr/iotn4313.h>
 337               	#elif defined (__AVR_ATtiny45__)
 338               	#  include <avr/iotn45.h>
 339               	#elif defined (__AVR_ATtiny85__)
 340               	#  include <avr/iotn85.h>
   1               	/* Copyright (c) 2005, Joerg Wunsch
   2               	   All rights reserved.
   3               	
   4               	   Redistribution and use in source and binary forms, with or without
   5               	   modification, are permitted provided that the following conditions are met:
   6               	
   7               	   * Redistributions of source code must retain the above copyright
   8               	     notice, this list of conditions and the following disclaimer.
   9               	
  10               	   * Redistributions in binary form must reproduce the above copyright
  11               	     notice, this list of conditions and the following disclaimer in
  12               	     the documentation and/or other materials provided with the
  13               	     distribution.
  14               	
  15               	   * Neither the name of the copyright holders nor the names of
  16               	     contributors may be used to endorse or promote products derived
  17               	     from this software without specific prior written permission.
  18               	
  19               	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  20               	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  21               	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  22               	  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  23               	  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  24               	  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  25               	  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  26               	  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
GAS LISTING /tmp/ccLNiDUh.s 			page 8


  27               	  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  28               	  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  29               	  POSSIBILITY OF SUCH DAMAGE. */
  30               	
  31               	/* $Id: iotn85.h 2115 2010-04-05 23:19:53Z arcanum $ */
  32               	
  33               	/* avr/iotn85.h - definitions for ATtiny85 */
  34               	
  35               	#ifndef _AVR_IOTN85_H_
  36               	#define _AVR_IOTN85_H_ 1
  37               	
  38               	#include <avr/iotnx5.h>
   1               	/* Copyright (c) 2005,2007 Anatoly Sokolov
  39               	
 341               	#elif defined (__AVR_ATtiny24__)
 342               	#  include <avr/iotn24.h>
 343               	#elif defined (__AVR_ATtiny24A__)
 344               	#  include <avr/iotn24a.h>
 345               	#elif defined (__AVR_ATtiny44__)
 346               	#  include <avr/iotn44.h>
 347               	#elif defined (__AVR_ATtiny44A__)
 348               	#  include <avr/iotn44a.h>
 349               	#elif defined (__AVR_ATtiny84__)
 350               	#  include <avr/iotn84.h>
 351               	#elif defined (__AVR_ATtiny84A__)
 352               	#  include <avr/iotn84a.h>  
 353               	#elif defined (__AVR_ATtiny261__)
 354               	#  include <avr/iotn261.h>
 355               	#elif defined (__AVR_ATtiny261A__)
 356               	#  include <avr/iotn261a.h>
 357               	#elif defined (__AVR_ATtiny461__)
 358               	#  include <avr/iotn461.h>
 359               	#elif defined (__AVR_ATtiny461A__)
 360               	#  include <avr/iotn461a.h>
 361               	#elif defined (__AVR_ATtiny861__)
 362               	#  include <avr/iotn861.h>
 363               	#elif defined (__AVR_ATtiny861A__)
 364               	#  include <avr/iotn861a.h>
 365               	#elif defined (__AVR_ATtiny43U__)
 366               	#  include <avr/iotn43u.h>
 367               	#elif defined (__AVR_ATtiny48__)
 368               	#  include <avr/iotn48.h>
 369               	#elif defined (__AVR_ATtiny88__)
 370               	#  include <avr/iotn88.h>
 371               	#elif defined (__AVR_ATtiny87__)
 372               	#  include <avr/iotn87.h>
 373               	#elif defined (__AVR_ATtiny167__)
 374               	#  include <avr/iotn167.h>
 375               	#elif defined (__AVR_AT90SCR100__)
 376               	#  include <avr/io90scr100.h>
 377               	#elif defined (__AVR_ATxmega16A4__)
 378               	#  include <avr/iox16a4.h>
 379               	#elif defined (__AVR_ATxmega16D4__)
 380               	#  include <avr/iox16d4.h>
 381               	#elif defined (__AVR_ATxmega32A4__)
 382               	#  include <avr/iox32a4.h>
 383               	#elif defined (__AVR_ATxmega32D4__)
GAS LISTING /tmp/ccLNiDUh.s 			page 9


 384               	#  include <avr/iox32d4.h>
 385               	#elif defined (__AVR_ATxmega64A1__)
 386               	#  include <avr/iox64a1.h>
 387               	#elif defined (__AVR_ATxmega64A1U__)
 388               	#  include <avr/iox64a1u.h>
 389               	#elif defined (__AVR_ATxmega64A3__)
 390               	#  include <avr/iox64a3.h>
 391               	#elif defined (__AVR_ATxmega64D3__)
 392               	#  include <avr/iox64d3.h>
 393               	#elif defined (__AVR_ATxmega128A1__)
 394               	#  include <avr/iox128a1.h>
 395               	#elif defined (__AVR_ATxmega128A1U__)
 396               	#  include <avr/iox128a1u.h>
 397               	#elif defined (__AVR_ATxmega128A3__)
 398               	#  include <avr/iox128a3.h>
 399               	#elif defined (__AVR_ATxmega128D3__)
 400               	#  include <avr/iox128d3.h>
 401               	#elif defined (__AVR_ATxmega192A3__)
 402               	#  include <avr/iox192a3.h>
 403               	#elif defined (__AVR_ATxmega192D3__)
 404               	#  include <avr/iox192d3.h>
 405               	#elif defined (__AVR_ATxmega256A3__)
 406               	#  include <avr/iox256a3.h>
 407               	#elif defined (__AVR_ATxmega256A3B__)
 408               	#  include <avr/iox256a3b.h>
 409               	#elif defined (__AVR_ATxmega256D3__)
 410               	#  include <avr/iox256d3.h>
 411               	#elif defined (__AVR_ATA6289__)
 412               	#  include <avr/ioa6289.h>
 413               	/* avr1: the following only supported for assembler programs */
 414               	#elif defined (__AVR_ATtiny28__)
 415               	#  include <avr/iotn28.h>
 416               	#elif defined (__AVR_AT90S1200__)
 417               	#  include <avr/io1200.h>
 418               	#elif defined (__AVR_ATtiny15__)
 419               	#  include <avr/iotn15.h>
 420               	#elif defined (__AVR_ATtiny12__)
 421               	#  include <avr/iotn12.h>
 422               	#elif defined (__AVR_ATtiny11__)
 423               	#  include <avr/iotn11.h>
 424               	#elif defined (__AVR_M3000__)
 425               	#  include <avr/iom3000.h>
 426               	#else
 427               	#  if !defined(__COMPILING_AVR_LIBC__)
 428               	#    warning "device type not defined"
 429               	#  endif
 430               	#endif
 431               	
 432               	#include <avr/portpins.h>
   1               	/* Copyright (c) 2003  Theodore A. Roth
 433               	
 434               	#include <avr/common.h>
   1               	/* Copyright (c) 2007 Eric B. Weddington
 435               	
 436               	#include <avr/version.h>
   1               	/* Copyright (c) 2005, Joerg Wunsch                               -*- c -*-
 437               	
GAS LISTING /tmp/ccLNiDUh.s 			page 10


 438               	/* Include fuse.h after individual IO header files. */
 439               	#include <avr/fuse.h>
   1               	/* Copyright (c) 2007, Atmel Corporation
 440               	
 441               	/* Include lock.h after individual IO header files. */
 442               	#include <avr/lock.h>
   1               	/* Copyright (c) 2007, Atmel Corporation
 443               	
  30               	
  31               	#define USEBR  USIDR
  32               	.global SendTick
  33               	SendTick:
  34:asmtest.S     **** 	ori r18, 0b00010101
  35:asmtest.S     **** 	ori r19, 0b00001101
  36:asmtest.S     **** 	ori r20, 0b00000101
  37:asmtest.S     **** 	out PORTB, r19
  38:asmtest.S     **** 	out PORTB, r19
  39:asmtest.S     **** 	out PORTB, r18
  40:asmtest.S     **** 	out PORTB, r18
  41:asmtest.S     **** 	out PORTB, r20
  42:asmtest.S     **** 	ret
  43               	
  44               	.global SendTestASM  // ( unsigned char * ptr_to_packet, uint8_t packet_length_longs ); (longs = pa
  45               	SendTestASM:
  46:asmtest.S     **** 	push r16
  47:asmtest.S     **** 	push r18
  48:asmtest.S     **** 	push r19
  49:asmtest.S     **** 	push r20
  50:asmtest.S     **** 	ldi r27,0
  51:asmtest.S     **** 	ldi r26,0
  52:asmtest.S     **** 	subi r26,lo8(-(ManchesterTable))
  53:asmtest.S     **** 	sbci r27,hi8(-(ManchesterTable))
  54               	//	mov r17, r26 // For backup
  55               		  //Manchester table now in X.
  56               	
  57               		//Move "Packet to send" into Z (R30, 31)
  58:asmtest.S     **** 	movw r30,r24
  59               	//	add r22,r24
  60               	//	adc r23,r25
  61               	
  62               		//r22 = how big to send.
  63               		
  64:asmtest.S     **** 	mov r16, r22
  65:asmtest.S     **** 	ld r18,Z+      //2  //Read off the bytes.
  66:asmtest.S     **** 	mov r26, r18   //1  R26 = To be read Manchester lookup
  67:asmtest.S     **** 	andi r26, 0x0f //1
  68:asmtest.S     **** 	subi r26,lo8(-(ManchesterTable)) //1
  69               	SendLoop:
  70:asmtest.S     **** 	tst r16
  71:asmtest.S     **** 	breq Done
  72               	
  73               		//Enable the USI
  74:asmtest.S     **** 	SBI USICR, USIWM0
  75               	
  76               	KeepGoing:			///subi r26,lo8(-(ManchesterTable))
  77               	
  78               		//Heavily interleved code.  Need a new OUTB every 8 cycles exactly.
GAS LISTING /tmp/ccLNiDUh.s 			page 11


  79:asmtest.S     ****     nop           //1 //Look, ma ONE EXTRA CYCLE!
  80               		//nop
  81               	
  82:asmtest.S     **** 	ld r19, X      //2
  83:asmtest.S     **** 	swap r18       //1
  84:asmtest.S     **** 	out USEBR, r19 //1  START HERE
  85:asmtest.S     **** 	mov r26, r18   //1
  86:asmtest.S     **** 	andi r26, 0x0f //1
  87:asmtest.S     **** 	subi r26,lo8(-(ManchesterTable)) //1
  88:asmtest.S     **** 	ld r19, X      //2
  89:asmtest.S     **** 	ld r18,Z+      //2  //Read off the bytes.
  90:asmtest.S     **** 	out USEBR, r19 //1 ** OK
  91:asmtest.S     **** 	mov r26, r18   //1
  92               	
  93               	
  94:asmtest.S     **** 	andi r26, 0x0f //1
  95:asmtest.S     **** 	subi r26,lo8(-(ManchesterTable)) //1
  96:asmtest.S     **** 	ld r19, X      //2
  97:asmtest.S     **** 	swap r18       //1
  98:asmtest.S     **** 	mov r26, r18   //1
  99:asmtest.S     **** 	out USEBR, r19 //1  ** OK
 100:asmtest.S     **** 	andi r26, 0x0f //1
 101:asmtest.S     **** 	subi r26,lo8(-(ManchesterTable)) //1
 102:asmtest.S     **** 	ld r19, X      //2
 103:asmtest.S     **** 	ld r18,Z+      //2  //Read off the bytes.
 104:asmtest.S     **** 	mov r26, r18   //1
 105:asmtest.S     **** 	out USEBR, r19 //1  **OK
 106               	
 107               	
 108:asmtest.S     **** 	andi r26, 0x0f //1
 109:asmtest.S     **** 	subi r26,lo8(-(ManchesterTable)) //1
 110:asmtest.S     **** 	ld r19, X      //2
 111:asmtest.S     **** 	swap r18       //1
 112:asmtest.S     **** 	mov r26, r18   //1
 113:asmtest.S     **** 	andi r26, 0x0f //1
 114:asmtest.S     **** 	out USEBR, r19 //1  ** OK 
 115:asmtest.S     **** 	subi r26,lo8(-(ManchesterTable)) //1
 116:asmtest.S     **** 	ld r19, X      //2
 117:asmtest.S     **** 	ld r18,Z+      //2  //Read off the bytes.
 118:asmtest.S     **** 	mov r26, r18   //1
 119:asmtest.S     **** 	andi r26, 0x0f //1
 120:asmtest.S     **** 	out USEBR, r19 //1 ** OK
 121:asmtest.S     **** 	subi r26,lo8(-(ManchesterTable)) //1
 122:asmtest.S     **** 	ld r19, X      //2
 123:asmtest.S     **** 	swap r18       //1
 124:asmtest.S     **** 	mov r26, r18   //1
 125:asmtest.S     **** 	andi r26, 0x0f //1
 126:asmtest.S     **** 	subi r26,lo8(-(ManchesterTable)) //1
 127:asmtest.S     **** 	out USEBR, r19 //1 ** OK
 128:asmtest.S     **** 	ld r19, X      //2
 129:asmtest.S     **** 	ld r18,Z+      //2  //Read off the bytes.
 130:asmtest.S     **** 	mov r26, r18   //1
 131:asmtest.S     **** 	andi r26, 0x0f //1
 132:asmtest.S     **** 	subi r26,lo8(-(ManchesterTable)) //1
 133:asmtest.S     **** 	out USEBR, r19 //1 ** OK
 134               	
 135:asmtest.S     **** 	dec r16         //1
GAS LISTING /tmp/ccLNiDUh.s 			page 12


 136:asmtest.S     **** 	brne KeepGoing  //2
 137               	Done:
 138:asmtest.S     **** 	nop
 139:asmtest.S     **** 	nop
 140:asmtest.S     **** 	nop
 141:asmtest.S     **** 	nop
 142:asmtest.S     **** 	andi r19,0
 143:asmtest.S     **** 	nop
 144:asmtest.S     **** 	out USEBR,r19 
 145:asmtest.S     **** 	CBI USICR, USIWM0
 146               	
 147:asmtest.S     **** 	pop r20
 148:asmtest.S     **** 	pop r19
 149:asmtest.S     **** 	pop r18
 150:asmtest.S     **** 	mov r24, r16
 151:asmtest.S     **** 	pop r16
 152:asmtest.S     **** 	ret
 153               	
 154               	
 155               	#define USEBRR  USIDR
 156               	//#define USEBRR  ADCL
 157               	
 158               	.global MaybeHaveDataASM
 159               	MaybeHaveDataASM:
 160               	
 161:asmtest.S     **** 	push r16
 162:asmtest.S     **** 	push r22
 163:asmtest.S     **** 	push r18
 164:asmtest.S     **** 	push r19
 165:asmtest.S     **** 	push r20
 166               	
 167               						//r22 = words in buffer.
 168:asmtest.S     **** 	movw r30,r24    //r24:r25 = pointer to staging ram.
 169               	
 170               		//In here, we're operating at 30 ~MHz (hopefully)
 171               		//We want to peel the data off the SPI bus as fast as possible!
 172               	
 173:asmtest.S     **** 	tst r22
 174:asmtest.S     **** 	breq rlend
 175               	rloop:
 176               	
 177               	///XXX TODO: Scrutenize the "breq" 
 178:asmtest.S     **** 	in r19,USEBRR  //1  ****
 179:asmtest.S     **** 	inc r19			//1
 180:asmtest.S     ****     breq rlend    //2???
 181:asmtest.S     ****     nop           //1????
 182:asmtest.S     **** 	dec r19		//1
 183:asmtest.S     **** 	breq rlend  //2????
 184:asmtest.S     **** 	nop         //1
 185:asmtest.S     **** 	nop         //1
 186               	
 187:asmtest.S     **** 	in r18,USEBRR  //1  ****
 188:asmtest.S     **** 	st Z+, r19    //2
 189:asmtest.S     **** 	st Z+, r18    //2
 190:asmtest.S     **** 	dec r22       //1
 191:asmtest.S     **** 	brne rloop    //2
 192               	
GAS LISTING /tmp/ccLNiDUh.s 			page 13


 193               	rlend:
 194:asmtest.S     **** 	mov r24,r22
 195:asmtest.S     **** 	pop r20
 196:asmtest.S     **** 	pop r19
 197:asmtest.S     **** 	pop r18
 198:asmtest.S     **** 	pop r22
 199:asmtest.S     **** 	pop r16
 200:asmtest.S     **** 	ret
GAS LISTING /tmp/ccLNiDUh.s 			page 14


DEFINED SYMBOLS
           asmtest.S:33     .text:0000000000000000 SendTick
           asmtest.S:45     .text:0000000000000012 SendTestASM
           asmtest.S:69     .text:000000000000002e SendLoop
           asmtest.S:137    .text:000000000000009a Done
           asmtest.S:76     .text:0000000000000034 KeepGoing
           asmtest.S:159    .text:00000000000000b6 MaybeHaveDataASM
           asmtest.S:193    .text:00000000000000e0 rlend
           asmtest.S:175    .text:00000000000000c6 rloop

UNDEFINED SYMBOLS
ManchesterTable
GAS LISTING /tmp/ccLNiDUh.s 			page 1


   1               		.file	"sendpack.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
 107               	.global	PacketA
 108               		.section	.progmem.data,"a",@progbits
 111               	PacketA:
 112 0000 55        		.byte	85
 113 0001 55        		.byte	85
 114 0002 55        		.byte	85
 115 0003 55        		.byte	85
 116 0004 55        		.byte	85
 117 0005 55        		.byte	85
 118 0006 55        		.byte	85
 119 0007 D5        		.byte	-43
 120 0008 FF        		.byte	-1
 121 0009 FF        		.byte	-1
 122 000a FF        		.byte	-1
 123 000b FF        		.byte	-1
 124 000c FF        		.byte	-1
 125 000d FF        		.byte	-1
 126 000e 00        		.byte	0
 127 000f 55        		.byte	85
 128 0010 00        		.byte	0
 129 0011 55        		.byte	85
 130 0012 00        		.byte	0
 131 0013 55        		.byte	85
 132 0014 08        		.byte	8
 133 0015 00        		.byte	0
 134 0016 45        		.byte	69
 135 0017 00        		.byte	0
 136 0018 00        		.byte	0
 137 0019 32        		.byte	50
 138 001a B3        		.byte	-77
 139 001b 1E        		.byte	30
 140 001c 00        		.byte	0
 141 001d 00        		.byte	0
 142 001e 80        		.byte	-128
 143 001f 11        		.byte	17
 144 0020 C6        		.byte	-58
 145 0021 8D        		.byte	-115
 146 0022 C0        		.byte	-64
 147 0023 A8        		.byte	-88
 148 0024 00        		.byte	0
 149 0025 67        		.byte	103
 150 0026 FF        		.byte	-1
 151 0027 FF        		.byte	-1
 152 0028 FF        		.byte	-1
 153 0029 FF        		.byte	-1
 154 002a 04        		.byte	4
 155 002b 00        		.byte	0
 156 002c 34        		.byte	52
 157 002d 00        		.byte	0
GAS LISTING /tmp/ccLNiDUh.s 			page 2


 158 002e 00        		.byte	0
 159 002f 1E        		.byte	30
 160 0030 18        		.byte	24
 161 0031 EE        		.byte	-18
 162 0032 43        		.byte	67
 163 0033 0A        		.byte	10
 164 0034 AA        		.byte	-86
 165 0035 AA        		.byte	-86
 166 0036 AA        		.byte	-86
 167 0037 AA        		.byte	-86
 168 0038 AA        		.byte	-86
 169 0039 AA        		.byte	-86
 170 003a AA        		.byte	-86
 171 003b AA        		.byte	-86
 172 003c AA        		.byte	-86
 173 003d AA        		.byte	-86
 174 003e AA        		.byte	-86
 175 003f AA        		.byte	-86
 176 0040 AA        		.byte	-86
 177 0041 AA        		.byte	-86
 178 0042 AA        		.byte	-86
 179 0043 AA        		.byte	-86
 180 0044 AA        		.byte	-86
 181 0045 AA        		.byte	-86
 182 0046 AA        		.byte	-86
 183 0047 AA        		.byte	-86
 184 0048 5D        		.byte	93
 185 0049 FA        		.byte	-6
 186 004a B6        		.byte	-74
 187 004b 1A        		.byte	26
 189               		.text
 191               	.Letext0:
 192               		.ident	"GCC: (GNU) 4.8.2"
GAS LISTING /tmp/ccLNiDUh.s 			page 3


DEFINED SYMBOLS
                            *ABS*:0000000000000000 sendpack.c
     /tmp/ccLNiDUh.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccLNiDUh.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccLNiDUh.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccLNiDUh.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccLNiDUh.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccLNiDUh.s:111    .progmem.data:0000000000000000 PacketA

NO UNDEFINED SYMBOLS
GAS LISTING /tmp/ccLNiDUh.s 			page 1


   1               		.file	"packetmater.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
  98               	.global	crc32b
 100               	crc32b:
 101               		.stabd	46,0,0
   1:packetmater.c **** //Packet mater.  A super tiny file that helps with checksums and ethernet CRCs.
   2:packetmater.c **** //CRC Was taken from linked page.
   3:packetmater.c **** 
   4:packetmater.c **** /*
   5:packetmater.c ****     Copyright (C) 2014 <>< Charles Lohr
   6:packetmater.c **** 
   7:packetmater.c **** 
   8:packetmater.c ****     Permission is hereby granted, free of charge, to any person obtaining a
   9:packetmater.c **** 	copy of this software and associated documentation files (the "Software"),
  10:packetmater.c **** 	to deal in the Software without restriction, including without limitation
  11:packetmater.c **** 	the rights to use, copy, modify, merge, publish, distribute, sublicense,
  12:packetmater.c **** 	and/or sell copies of the Software, and to permit persons to whom the
  13:packetmater.c **** 	Software is furnished to do so, subject to the following conditions:
  14:packetmater.c **** 
  15:packetmater.c ****     The above copyright notice and this permission notice shall be included
  16:packetmater.c **** 	in all copies or substantial portions of the Software.
  17:packetmater.c **** 
  18:packetmater.c ****     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  19:packetmater.c **** 	OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  20:packetmater.c **** 	MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  21:packetmater.c **** 	IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
  22:packetmater.c **** 	CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
  23:packetmater.c **** 	TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  24:packetmater.c **** 	SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  25:packetmater.c **** */
  26:packetmater.c **** #include "packetmater.h"
  27:packetmater.c **** 
  28:packetmater.c **** //Fix all checksums for UDP packets and add etherlink CRC.
  29:packetmater.c **** uint16_t Ethernetize( unsigned char * packet, int plen, int udplenoverride )
  30:packetmater.c **** {
  31:packetmater.c **** 	plen -= 12;
  32:packetmater.c **** 	packet += 8; //User must provide preamble.
  33:packetmater.c **** 
  34:packetmater.c **** 	if( (udplenoverride+8) > plen-34 )
  35:packetmater.c **** 		plen = (udplenoverride+8) + 34;
  36:packetmater.c **** 
  37:packetmater.c **** 	//Need to buffer to 4-byte boundaries.
  38:packetmater.c **** 	plen = ((plen - 1)&0xfffc) + 4;
  39:packetmater.c **** 
  40:packetmater.c **** 	if( packet[12] == 0x08 && packet[13] == 0x00 )
  41:packetmater.c **** 	{
  42:packetmater.c **** 		uint16_t fullpacklen = plen-14;
  43:packetmater.c **** 		packet[16] = fullpacklen>>8;
  44:packetmater.c **** 		packet[17] = fullpacklen&0xff;
  45:packetmater.c **** 		packet[24] = 0;
  46:packetmater.c **** 		packet[25] = 0;
GAS LISTING /tmp/ccLNiDUh.s 			page 2


  47:packetmater.c **** 		uint16_t csumr;
  48:packetmater.c **** //		fprintf( stderr, "Header checksum: 0x%04x\n", csumr = csrange(14,20) );
  49:packetmater.c **** 		csumr = internet_checksum( &packet[14], 20 );
  50:packetmater.c **** 
  51:packetmater.c **** 		packet[24] = csumr>>8;
  52:packetmater.c **** 		packet[25] = csumr&0xff;
  53:packetmater.c **** 
  54:packetmater.c **** 		if( packet[23] == 0x11  )
  55:packetmater.c **** 		{
  56:packetmater.c **** 			uint16_t udppacklen = udplenoverride + 8;//fullpacklen-20;
  57:packetmater.c **** 			packet[32+6] = udppacklen>>8;
  58:packetmater.c **** 			packet[32+7] = udppacklen&0xff;
  59:packetmater.c **** 
  60:packetmater.c **** 			uint16_t pseudo = 0x11 + 0x8 + udppacklen-8; //UDP number + size + length (of packet)
  61:packetmater.c **** 			packet[40+0] = pseudo>>8;
  62:packetmater.c **** 			packet[40+1] = pseudo&0xff;
  63:packetmater.c **** 
  64:packetmater.c **** 			csumr = internet_checksum( &packet[26], udppacklen+8 );
  65:packetmater.c **** 			if( csumr == 0 ) csumr = 0xffff;
  66:packetmater.c **** 			packet[40+0] = csumr>>8;
  67:packetmater.c **** 			packet[40+1] = csumr&0xff;
  68:packetmater.c **** 		}
  69:packetmater.c **** 	}
  70:packetmater.c **** 
  71:packetmater.c **** 
  72:packetmater.c **** 	uint32_t crc = crc32b( 0, packet, plen );
  73:packetmater.c **** 
  74:packetmater.c **** 	packet[plen+0] = crc & 0xff;
  75:packetmater.c **** 	packet[plen+1] = (crc>>8) & 0xff;
  76:packetmater.c **** 	packet[plen+2] = (crc>>16) & 0xff;
  77:packetmater.c **** 	packet[plen+3] = (crc>>24) & 0xff;
  78:packetmater.c **** 
  79:packetmater.c **** 	return plen;
  80:packetmater.c **** }
  81:packetmater.c **** 
  82:packetmater.c **** 
  83:packetmater.c **** //From: http://www.hackersdelight.org/hdcodetxt/crc.c.txt
  84:packetmater.c **** uint32_t crc32b(uint32_t crc, unsigned char *message, int len) {
 103               	.LM0:
 104               	.LFBB1:
 105 0000 AF92      		push r10
 106 0002 BF92      		push r11
 107 0004 CF92      		push r12
 108 0006 DF92      		push r13
 109 0008 EF92      		push r14
 110 000a FF92      		push r15
 111 000c 0F93      		push r16
 112 000e 1F93      		push r17
 113 0010 CF93      		push r28
 114 0012 DF93      		push r29
 115               	/* prologue: function */
 116               	/* frame size = 0 */
 117               	/* stack size = 10 */
 118               	.L__stack_usage = 10
 119 0014 5901      		movw r10,r18
  85:packetmater.c ****    int i, j;
  86:packetmater.c ****    uint32_t mask;
GAS LISTING /tmp/ccLNiDUh.s 			page 3


  87:packetmater.c **** 	uint8_t byte;
  88:packetmater.c **** 
  89:packetmater.c ****    i = 0;
  90:packetmater.c **** //   crc = 0xFFFFFFFF;
  91:packetmater.c **** 	crc = ~crc;
 121               	.LM1:
 122 0016 6095      		com r22
 123 0018 7095      		com r23
 124 001a 8095      		com r24
 125 001c 9095      		com r25
  92:packetmater.c ****    while (i < len) {
 127               	.LM2:
 128 001e FA01      		movw r30,r20
 129               	.L2:
 130 0020 9F01      		movw r18,r30
 131 0022 241B      		sub r18,r20
 132 0024 350B      		sbc r19,r21
 134               	.LM3:
 135 0026 2A15      		cp r18,r10
 136 0028 3B05      		cpc r19,r11
 137 002a 04F4      		brge .L8
  93:packetmater.c ****       byte = message[i];            // Get next byte.
 139               	.LM4:
 140 002c 2191      		ld r18,Z+
  94:packetmater.c ****       crc = crc ^ byte;
 142               	.LM5:
 143 002e 6227      		eor r22,r18
 144 0030 A8E0      		ldi r26,lo8(8)
 145 0032 B0E0      		ldi r27,0
 146               	.L4:
  95:packetmater.c ****       for (j = 7; j >= 0; j--) {    // Do eight times.
  96:packetmater.c ****          mask = -(crc & 1);
  97:packetmater.c ****          crc = (crc >> 1) ^ (0xEDB88320 & mask);
 148               	.LM6:
 149 0034 8B01      		movw r16,r22
 150 0036 9C01      		movw r18,r24
 151 0038 3695      		lsr r19
 152 003a 2795      		ror r18
 153 003c 1795      		ror r17
 154 003e 0795      		ror r16
  96:packetmater.c ****          mask = -(crc & 1);
 156               	.LM7:
 157 0040 6B01      		movw r12,r22
 158 0042 7C01      		movw r14,r24
 159 0044 C1E0      		ldi r28,1
 160 0046 CC22      		and r12,r28
 161 0048 DD24      		clr r13
 162 004a EE24      		clr r14
 163 004c FF24      		clr r15
 164 004e 6627      		clr r22
 165 0050 7727      		clr r23
 166 0052 CB01      		movw r24,r22
 167 0054 6C19      		sub r22,r12
 168 0056 7D09      		sbc r23,r13
 169 0058 8E09      		sbc r24,r14
 170 005a 9F09      		sbc r25,r15
 172               	.LM8:
GAS LISTING /tmp/ccLNiDUh.s 			page 4


 173 005c 6072      		andi r22,32
 174 005e 7378      		andi r23,131
 175 0060 887B      		andi r24,184
 176 0062 9D7E      		andi r25,237
 177 0064 6027      		eor r22,r16
 178 0066 7127      		eor r23,r17
 179 0068 8227      		eor r24,r18
 180 006a 9327      		eor r25,r19
 181 006c 1197      		sbiw r26,1
  95:packetmater.c ****       for (j = 7; j >= 0; j--) {    // Do eight times.
 183               	.LM9:
 184 006e 1097      		sbiw r26,0
 185 0070 01F4      		brne .L4
 186 0072 00C0      		rjmp .L2
 187               	.L8:
  98:packetmater.c ****       }
  99:packetmater.c ****       i = i + 1;
 100:packetmater.c ****    }
 101:packetmater.c ****    return ~crc;
 189               	.LM10:
 190 0074 6095      		com r22
 191 0076 7095      		com r23
 192 0078 8095      		com r24
 193 007a 9095      		com r25
 194               	/* epilogue start */
 102:packetmater.c **** }
 196               	.LM11:
 197 007c DF91      		pop r29
 198 007e CF91      		pop r28
 199 0080 1F91      		pop r17
 200 0082 0F91      		pop r16
 201 0084 FF90      		pop r15
 202 0086 EF90      		pop r14
 203 0088 DF90      		pop r13
 204 008a CF90      		pop r12
 205 008c BF90      		pop r11
 206 008e AF90      		pop r10
 207 0090 0895      		ret
 212               	.Lscope1:
 214               		.stabd	78,0,0
 218               	.global	internet_checksum
 220               	internet_checksum:
 221               		.stabd	46,0,0
 103:packetmater.c **** 
 104:packetmater.c **** uint16_t internet_checksum( const unsigned char * start, uint16_t len )
 105:packetmater.c **** {
 223               	.LM12:
 224               	.LFBB2:
 225 0092 CF93      		push r28
 226 0094 DF93      		push r29
 227               	/* prologue: function */
 228               	/* frame size = 0 */
 229               	/* stack size = 2 */
 230               	.L__stack_usage = 2
 231 0096 9B01      		movw r18,r22
 232 0098 DC01      		movw r26,r24
 106:packetmater.c **** 	uint16_t i;
GAS LISTING /tmp/ccLNiDUh.s 			page 5


 107:packetmater.c **** 	const uint16_t * wptr = (uint16_t*) start;
 108:packetmater.c **** 	uint32_t csum = 0;
 234               	.LM13:
 235 009a 40E0      		ldi r20,0
 236 009c 50E0      		ldi r21,0
 237 009e BA01      		movw r22,r20
 109:packetmater.c **** 	for (i=1;i<len;i+=2)
 239               	.LM14:
 240 00a0 E1E0      		ldi r30,lo8(1)
 241 00a2 F0E0      		ldi r31,0
 242               	.L10:
 244               	.LM15:
 245 00a4 E217      		cp r30,r18
 246 00a6 F307      		cpc r31,r19
 247 00a8 00F4      		brsh .L18
 110:packetmater.c **** 	{
 111:packetmater.c **** 		csum = csum + (uint32_t)(*(wptr++));	
 249               	.LM16:
 250 00aa CD91      		ld r28,X+
 251 00ac DD91      		ld r29,X+
 252 00ae 4C0F      		add r20,r28
 253 00b0 5D1F      		adc r21,r29
 254 00b2 611D      		adc r22,__zero_reg__
 255 00b4 711D      		adc r23,__zero_reg__
 109:packetmater.c **** 	for (i=1;i<len;i+=2)
 257               	.LM17:
 258 00b6 3296      		adiw r30,2
 259 00b8 00C0      		rjmp .L10
 260               	.L18:
 261 00ba F901      		movw r30,r18
 262 00bc EE7F      		andi r30,254
 263 00be E80F      		add r30,r24
 264 00c0 F91F      		adc r31,r25
 112:packetmater.c **** 	}
 113:packetmater.c **** 	if( len & 1 )  //See if there's an odd number of bytes?
 266               	.LM18:
 267 00c2 20FF      		sbrs r18,0
 268 00c4 00C0      		rjmp .L13
 269               	.LBB2:
 114:packetmater.c **** 	{
 115:packetmater.c **** 		uint8_t * tt = (uint8_t*)wptr;
 116:packetmater.c **** 		csum += *tt;
 271               	.LM19:
 272 00c6 8081      		ld r24,Z
 273 00c8 480F      		add r20,r24
 274 00ca 511D      		adc r21,__zero_reg__
 275 00cc 611D      		adc r22,__zero_reg__
 276 00ce 711D      		adc r23,__zero_reg__
 277               	.L13:
 278               	.LBE2:
 117:packetmater.c **** 	}
 118:packetmater.c **** 	while (csum>>16)
 280               	.LM20:
 281 00d0 CB01      		movw r24,r22
 282 00d2 AA27      		clr r26
 283 00d4 BB27      		clr r27
 284 00d6 0097      		sbiw r24,0
GAS LISTING /tmp/ccLNiDUh.s 			page 6


 285 00d8 A105      		cpc r26,__zero_reg__
 286 00da B105      		cpc r27,__zero_reg__
 287 00dc 01F0      		breq .L19
 119:packetmater.c **** 		csum = (csum & 0xFFFF)+(csum >> 16);
 289               	.LM21:
 290 00de 6627      		clr r22
 291 00e0 7727      		clr r23
 292 00e2 480F      		add r20,r24
 293 00e4 591F      		adc r21,r25
 294 00e6 6A1F      		adc r22,r26
 295 00e8 7B1F      		adc r23,r27
 296 00ea 00C0      		rjmp .L13
 297               	.L19:
 120:packetmater.c **** 	csum = (csum>>8) | ((csum&0xff)<<8);
 299               	.LM22:
 300 00ec BB27      		clr r27
 301 00ee A72F      		mov r26,r23
 302 00f0 962F      		mov r25,r22
 303 00f2 852F      		mov r24,r21
 304 00f4 762F      		mov r23,r22
 305 00f6 652F      		mov r22,r21
 306 00f8 542F      		mov r21,r20
 307 00fa 4427      		clr r20
 308 00fc 6627      		clr r22
 309 00fe 7727      		clr r23
 310 0100 482B      		or r20,r24
 311 0102 592B      		or r21,r25
 312 0104 6A2B      		or r22,r26
 313 0106 7B2B      		or r23,r27
 121:packetmater.c **** 	return ~csum;
 315               	.LM23:
 316 0108 CA01      		movw r24,r20
 317 010a 8095      		com r24
 318 010c 9095      		com r25
 319               	/* epilogue start */
 122:packetmater.c **** }
 321               	.LM24:
 322 010e DF91      		pop r29
 323 0110 CF91      		pop r28
 324 0112 0895      		ret
 329               	.Lscope2:
 331               		.stabd	78,0,0
 336               	.global	Ethernetize
 338               	Ethernetize:
 339               		.stabd	46,0,0
  30:packetmater.c **** {
 341               	.LM25:
 342               	.LFBB3:
 343 0114 AF92      		push r10
 344 0116 BF92      		push r11
 345 0118 CF92      		push r12
 346 011a DF92      		push r13
 347 011c EF92      		push r14
 348 011e FF92      		push r15
 349 0120 0F93      		push r16
 350 0122 1F93      		push r17
 351 0124 CF93      		push r28
GAS LISTING /tmp/ccLNiDUh.s 			page 7


 352 0126 DF93      		push r29
 353               	/* prologue: function */
 354               	/* frame size = 0 */
 355               	/* stack size = 10 */
 356               	.L__stack_usage = 10
 357 0128 EC01      		movw r28,r24
 358 012a 7A01      		movw r14,r20
  32:packetmater.c **** 	packet += 8; //User must provide preamble.
 360               	.LM26:
 361 012c 5C01      		movw r10,r24
 362 012e 88E0      		ldi r24,8
 363 0130 A80E      		add r10,r24
 364 0132 B11C      		adc r11,__zero_reg__
  34:packetmater.c **** 	if( (udplenoverride+8) > plen-34 )
 366               	.LM27:
 367 0134 9A01      		movw r18,r20
 368 0136 295F      		subi r18,-7
 369 0138 3F4F      		sbci r19,-1
 370 013a CB01      		movw r24,r22
 371 013c 8E97      		sbiw r24,46
 372 013e 2817      		cp r18,r24
 373 0140 3907      		cpc r19,r25
 374 0142 04F4      		brge .L21
  31:packetmater.c **** 	plen -= 12;
 376               	.LM28:
 377 0144 8B01      		movw r16,r22
 378 0146 0C50      		subi r16,12
 379 0148 1109      		sbc r17,__zero_reg__
 380 014a 00C0      		rjmp .L22
 381               	.L21:
  35:packetmater.c **** 		plen = (udplenoverride+8) + 34;
 383               	.LM29:
 384 014c 8A01      		movw r16,r20
 385 014e 065D      		subi r16,-42
 386 0150 1F4F      		sbci r17,-1
 387               	.L22:
  38:packetmater.c **** 	plen = ((plen - 1)&0xfffc) + 4;
 389               	.LM30:
 390 0152 0150      		subi r16,1
 391 0154 1109      		sbc r17,__zero_reg__
 392 0156 0C7F      		andi r16,252
 393 0158 6801      		movw r12,r16
 394 015a 84E0      		ldi r24,4
 395 015c C80E      		add r12,r24
 396 015e D11C      		adc r13,__zero_reg__
  40:packetmater.c **** 	if( packet[12] == 0x08 && packet[13] == 0x00 )
 398               	.LM31:
 399 0160 8C89      		ldd r24,Y+20
 400 0162 8830      		cpi r24,lo8(8)
 401 0164 01F4      		brne .L24
  40:packetmater.c **** 	if( packet[12] == 0x08 && packet[13] == 0x00 )
 403               	.LM32:
 404 0166 8D89      		ldd r24,Y+21
 405 0168 8111      		cpse r24,__zero_reg__
 406 016a 00C0      		rjmp .L24
 407               	.LBB3:
  42:packetmater.c **** 		uint16_t fullpacklen = plen-14;
GAS LISTING /tmp/ccLNiDUh.s 			page 8


 409               	.LM33:
 410 016c C801      		movw r24,r16
 411 016e 0A97      		sbiw r24,10
  43:packetmater.c **** 		packet[16] = fullpacklen>>8;
 413               	.LM34:
 414 0170 988F      		std Y+24,r25
  44:packetmater.c **** 		packet[17] = fullpacklen&0xff;
 416               	.LM35:
 417 0172 898F      		std Y+25,r24
  45:packetmater.c **** 		packet[24] = 0;
 419               	.LM36:
 420 0174 18A2      		std Y+32,__zero_reg__
  46:packetmater.c **** 		packet[25] = 0;
 422               	.LM37:
 423 0176 19A2      		std Y+33,__zero_reg__
  49:packetmater.c **** 		csumr = internet_checksum( &packet[14], 20 );
 425               	.LM38:
 426 0178 64E1      		ldi r22,lo8(20)
 427 017a 70E0      		ldi r23,0
 428 017c CE01      		movw r24,r28
 429 017e 4696      		adiw r24,22
 430 0180 00D0      		rcall internet_checksum
  51:packetmater.c **** 		packet[24] = csumr>>8;
 432               	.LM39:
 433 0182 98A3      		std Y+32,r25
  52:packetmater.c **** 		packet[25] = csumr&0xff;
 435               	.LM40:
 436 0184 89A3      		std Y+33,r24
  54:packetmater.c **** 		if( packet[23] == 0x11  )
 438               	.LM41:
 439 0186 8F8D      		ldd r24,Y+31
 440 0188 8131      		cpi r24,lo8(17)
 441 018a 01F4      		brne .L24
 442               	.LBB4:
  56:packetmater.c **** 			uint16_t udppacklen = udplenoverride + 8;//fullpacklen-20;
 444               	.LM42:
 445 018c B701      		movw r22,r14
 446 018e 685F      		subi r22,-8
 447 0190 7F4F      		sbci r23,-1
  57:packetmater.c **** 			packet[32+6] = udppacklen>>8;
 449               	.LM43:
 450 0192 7EA7      		std Y+46,r23
  58:packetmater.c **** 			packet[32+7] = udppacklen&0xff;
 452               	.LM44:
 453 0194 6FA7      		std Y+47,r22
  60:packetmater.c **** 			uint16_t pseudo = 0x11 + 0x8 + udppacklen-8; //UDP number + size + length (of packet)
 455               	.LM45:
 456 0196 89E1      		ldi r24,25
 457 0198 E80E      		add r14,r24
 458 019a F11C      		adc r15,__zero_reg__
  61:packetmater.c **** 			packet[40+0] = pseudo>>8;
 460               	.LM46:
 461 019c F8AA      		std Y+48,r15
  62:packetmater.c **** 			packet[40+1] = pseudo&0xff;
 463               	.LM47:
 464 019e E9AA      		std Y+49,r14
  64:packetmater.c **** 			csumr = internet_checksum( &packet[26], udppacklen+8 );
GAS LISTING /tmp/ccLNiDUh.s 			page 9


 466               	.LM48:
 467 01a0 685F      		subi r22,-8
 468 01a2 7F4F      		sbci r23,-1
 469 01a4 CE01      		movw r24,r28
 470 01a6 8296      		adiw r24,34
 471 01a8 00D0      		rcall internet_checksum
  65:packetmater.c **** 			if( csumr == 0 ) csumr = 0xffff;
 473               	.LM49:
 474 01aa 0097      		sbiw r24,0
 475 01ac 01F4      		brne .L26
 476 01ae 8FEF      		ldi r24,lo8(-1)
 477 01b0 9FEF      		ldi r25,lo8(-1)
 478               	.L26:
  66:packetmater.c **** 			packet[40+0] = csumr>>8;
 480               	.LM50:
 481 01b2 98AB      		std Y+48,r25
  67:packetmater.c **** 			packet[40+1] = csumr&0xff;
 483               	.LM51:
 484 01b4 89AB      		std Y+49,r24
 485               	.L24:
 486               	.LBE4:
 487               	.LBE3:
  72:packetmater.c **** 	uint32_t crc = crc32b( 0, packet, plen );
 489               	.LM52:
 490 01b6 9601      		movw r18,r12
 491 01b8 A501      		movw r20,r10
 492 01ba 60E0      		ldi r22,0
 493 01bc 70E0      		ldi r23,0
 494 01be CB01      		movw r24,r22
 495 01c0 00D0      		rcall crc32b
  74:packetmater.c **** 	packet[plen+0] = crc & 0xff;
 497               	.LM53:
 498 01c2 F501      		movw r30,r10
 499 01c4 EC0D      		add r30,r12
 500 01c6 FD1D      		adc r31,r13
 501 01c8 6083      		st Z,r22
  75:packetmater.c **** 	packet[plen+1] = (crc>>8) & 0xff;
 503               	.LM54:
 504 01ca F501      		movw r30,r10
 505 01cc E00F      		add r30,r16
 506 01ce F11F      		adc r31,r17
 507 01d0 7583      		std Z+5,r23
  76:packetmater.c **** 	packet[plen+2] = (crc>>16) & 0xff;
 509               	.LM55:
 510 01d2 8683      		std Z+6,r24
  77:packetmater.c **** 	packet[plen+3] = (crc>>24) & 0xff;
 512               	.LM56:
 513 01d4 9783      		std Z+7,r25
  80:packetmater.c **** }
 515               	.LM57:
 516 01d6 C601      		movw r24,r12
 517               	/* epilogue start */
 518 01d8 DF91      		pop r29
 519 01da CF91      		pop r28
 520 01dc 1F91      		pop r17
 521 01de 0F91      		pop r16
 522 01e0 FF90      		pop r15
GAS LISTING /tmp/ccLNiDUh.s 			page 10


 523 01e2 EF90      		pop r14
 524 01e4 DF90      		pop r13
 525 01e6 CF90      		pop r12
 526 01e8 BF90      		pop r11
 527 01ea AF90      		pop r10
 528 01ec 0895      		ret
 533               	.Lscope3:
 535               		.stabd	78,0,0
 537               	.Letext0:
 538               		.ident	"GCC: (GNU) 4.8.2"
GAS LISTING /tmp/ccLNiDUh.s 			page 11


DEFINED SYMBOLS
                            *ABS*:0000000000000000 packetmater.c
     /tmp/ccLNiDUh.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccLNiDUh.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccLNiDUh.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccLNiDUh.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccLNiDUh.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccLNiDUh.s:100    .text:0000000000000000 crc32b
     /tmp/ccLNiDUh.s:220    .text:0000000000000092 internet_checksum
     /tmp/ccLNiDUh.s:338    .text:0000000000000114 Ethernetize

NO UNDEFINED SYMBOLS
